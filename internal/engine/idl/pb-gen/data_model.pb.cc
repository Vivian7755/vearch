// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: data_model.proto

#include "data_model.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace vearchpb {
PROTOBUF_CONSTEXPR Field::Field(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.option_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FieldDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FieldDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FieldDefaultTypeInternal() {}
  union {
    Field _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FieldDefaultTypeInternal _Field_default_instance_;
PROTOBUF_CONSTEXPR Document::Document(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.fields_)*/{}
  , /*decltype(_impl_.p_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DocumentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DocumentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DocumentDefaultTypeInternal() {}
  union {
    Document _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DocumentDefaultTypeInternal _Document_default_instance_;
PROTOBUF_CONSTEXPR Item::Item(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.msg_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.err_)*/nullptr
  , /*decltype(_impl_.doc_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ItemDefaultTypeInternal() {}
  union {
    Item _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ItemDefaultTypeInternal _Item_default_instance_;
PROTOBUF_CONSTEXPR VectorMetaInfo::VectorMetaInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.store_param_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dimension_)*/0
  , /*decltype(_impl_.value_type_)*/0
  , /*decltype(_impl_.store_type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VectorMetaInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorMetaInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorMetaInfoDefaultTypeInternal() {}
  union {
    VectorMetaInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorMetaInfoDefaultTypeInternal _VectorMetaInfo_default_instance_;
PROTOBUF_CONSTEXPR FieldMetaInfo::FieldMetaInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.vector_meta_info_)*/nullptr
  , /*decltype(_impl_.data_type_)*/0
  , /*decltype(_impl_.is_index_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FieldMetaInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FieldMetaInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FieldMetaInfoDefaultTypeInternal() {}
  union {
    FieldMetaInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FieldMetaInfoDefaultTypeInternal _FieldMetaInfo_default_instance_;
PROTOBUF_CONSTEXPR TableMetaInfo::TableMetaInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.field_meta_info_)*/{}
  , /*decltype(_impl_.primary_key_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.primary_key_type_)*/0
  , /*decltype(_impl_.partitions_num_)*/0
  , /*decltype(_impl_.replicas_num_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TableMetaInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TableMetaInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TableMetaInfoDefaultTypeInternal() {}
  union {
    TableMetaInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TableMetaInfoDefaultTypeInternal _TableMetaInfo_default_instance_;
PROTOBUF_CONSTEXPR Table::Table(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.table_meta_info_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TableDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TableDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TableDefaultTypeInternal() {}
  union {
    Table _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TableDefaultTypeInternal _Table_default_instance_;
PROTOBUF_CONSTEXPR DB_UserPasswordPairEntry_DoNotUse::DB_UserPasswordPairEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct DB_UserPasswordPairEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DB_UserPasswordPairEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DB_UserPasswordPairEntry_DoNotUseDefaultTypeInternal() {}
  union {
    DB_UserPasswordPairEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DB_UserPasswordPairEntry_DoNotUseDefaultTypeInternal _DB_UserPasswordPairEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR DB::DB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tables_)*/{}
  , /*decltype(_impl_.user_password_pair_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DBDefaultTypeInternal() {}
  union {
    DB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DBDefaultTypeInternal _DB_default_instance_;
}  // namespace vearchpb
static ::_pb::Metadata file_level_metadata_data_5fmodel_2eproto[9];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_data_5fmodel_2eproto[4];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_data_5fmodel_2eproto = nullptr;

const uint32_t TableStruct_data_5fmodel_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vearchpb::Field, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vearchpb::Field, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::vearchpb::Field, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::vearchpb::Field, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::vearchpb::Field, _impl_.option_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vearchpb::Document, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vearchpb::Document, _impl_.p_key_),
  PROTOBUF_FIELD_OFFSET(::vearchpb::Document, _impl_.fields_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vearchpb::Item, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vearchpb::Item, _impl_.err_),
  PROTOBUF_FIELD_OFFSET(::vearchpb::Item, _impl_.doc_),
  PROTOBUF_FIELD_OFFSET(::vearchpb::Item, _impl_.msg_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vearchpb::VectorMetaInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vearchpb::VectorMetaInfo, _impl_.dimension_),
  PROTOBUF_FIELD_OFFSET(::vearchpb::VectorMetaInfo, _impl_.value_type_),
  PROTOBUF_FIELD_OFFSET(::vearchpb::VectorMetaInfo, _impl_.store_type_),
  PROTOBUF_FIELD_OFFSET(::vearchpb::VectorMetaInfo, _impl_.store_param_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vearchpb::FieldMetaInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vearchpb::FieldMetaInfo, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::vearchpb::FieldMetaInfo, _impl_.data_type_),
  PROTOBUF_FIELD_OFFSET(::vearchpb::FieldMetaInfo, _impl_.is_index_),
  PROTOBUF_FIELD_OFFSET(::vearchpb::FieldMetaInfo, _impl_.vector_meta_info_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vearchpb::TableMetaInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vearchpb::TableMetaInfo, _impl_.primary_key_name_),
  PROTOBUF_FIELD_OFFSET(::vearchpb::TableMetaInfo, _impl_.primary_key_type_),
  PROTOBUF_FIELD_OFFSET(::vearchpb::TableMetaInfo, _impl_.partitions_num_),
  PROTOBUF_FIELD_OFFSET(::vearchpb::TableMetaInfo, _impl_.replicas_num_),
  PROTOBUF_FIELD_OFFSET(::vearchpb::TableMetaInfo, _impl_.field_meta_info_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vearchpb::Table, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vearchpb::Table, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::vearchpb::Table, _impl_.table_meta_info_),
  PROTOBUF_FIELD_OFFSET(::vearchpb::DB_UserPasswordPairEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::vearchpb::DB_UserPasswordPairEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vearchpb::DB_UserPasswordPairEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::vearchpb::DB_UserPasswordPairEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vearchpb::DB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vearchpb::DB, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::vearchpb::DB, _impl_.tables_),
  PROTOBUF_FIELD_OFFSET(::vearchpb::DB, _impl_.user_password_pair_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::vearchpb::Field)},
  { 10, -1, -1, sizeof(::vearchpb::Document)},
  { 18, -1, -1, sizeof(::vearchpb::Item)},
  { 27, -1, -1, sizeof(::vearchpb::VectorMetaInfo)},
  { 37, -1, -1, sizeof(::vearchpb::FieldMetaInfo)},
  { 47, -1, -1, sizeof(::vearchpb::TableMetaInfo)},
  { 58, -1, -1, sizeof(::vearchpb::Table)},
  { 66, 74, -1, sizeof(::vearchpb::DB_UserPasswordPairEntry_DoNotUse)},
  { 76, -1, -1, sizeof(::vearchpb::DB)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::vearchpb::_Field_default_instance_._instance,
  &::vearchpb::_Document_default_instance_._instance,
  &::vearchpb::_Item_default_instance_._instance,
  &::vearchpb::_VectorMetaInfo_default_instance_._instance,
  &::vearchpb::_FieldMetaInfo_default_instance_._instance,
  &::vearchpb::_TableMetaInfo_default_instance_._instance,
  &::vearchpb::_Table_default_instance_._instance,
  &::vearchpb::_DB_UserPasswordPairEntry_DoNotUse_default_instance_._instance,
  &::vearchpb::_DB_default_instance_._instance,
};

const char descriptor_table_protodef_data_5fmodel_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\020data_model.proto\022\010vearchpb\032\014errors.pro"
  "to\"n\n\005Field\022\014\n\004name\030\001 \001(\t\022!\n\004type\030\002 \001(\0162"
  "\023.vearchpb.FieldType\022\r\n\005value\030\003 \001(\014\022%\n\006o"
  "ption\030\004 \001(\0162\025.vearchpb.FieldOption\":\n\010Do"
  "cument\022\r\n\005p_key\030\001 \001(\t\022\037\n\006fields\030\002 \003(\0132\017."
  "vearchpb.Field\"R\n\004Item\022\034\n\003err\030\001 \001(\0132\017.ve"
  "archpb.Error\022\037\n\003doc\030\002 \001(\0132\022.vearchpb.Doc"
  "ument\022\013\n\003msg\030\003 \001(\t\"\365\001\n\016VectorMetaInfo\022\021\n"
  "\tdimension\030\001 \001(\005\0226\n\nvalue_type\030\002 \001(\0162\".v"
  "earchpb.VectorMetaInfo.ValueType\0226\n\nstor"
  "e_type\030\003 \001(\0162\".vearchpb.VectorMetaInfo.S"
  "toreType\022\023\n\013store_param\030\004 \001(\t\"!\n\tValueTy"
  "pe\022\t\n\005FLOAT\020\000\022\t\n\005UINT8\020\001\"(\n\tStoreType\022\016\n"
  "\nMEMORYONLY\020\000\022\013\n\007ROCKSDB\020\001\"\213\001\n\rFieldMeta"
  "Info\022\014\n\004name\030\001 \001(\t\022&\n\tdata_type\030\002 \001(\0162\023."
  "vearchpb.FieldType\022\020\n\010is_index\030\003 \001(\010\0222\n\020"
  "vector_meta_info\030\004 \001(\0132\030.vearchpb.Vector"
  "MetaInfo\"\270\001\n\rTableMetaInfo\022\030\n\020primary_ke"
  "y_name\030\001 \001(\t\022-\n\020primary_key_type\030\002 \001(\0162\023"
  ".vearchpb.FieldType\022\026\n\016partitions_num\030\003 "
  "\001(\005\022\024\n\014replicas_num\030\004 \001(\005\0220\n\017field_meta_"
  "info\030\005 \003(\0132\027.vearchpb.FieldMetaInfo\"G\n\005T"
  "able\022\014\n\004name\030\001 \001(\t\0220\n\017table_meta_info\030\002 "
  "\001(\0132\027.vearchpb.TableMetaInfo\"\254\001\n\002DB\022\014\n\004n"
  "ame\030\001 \001(\t\022\037\n\006tables\030\002 \003(\0132\017.vearchpb.Tab"
  "le\022>\n\022user_password_pair\030\003 \003(\0132\".vearchp"
  "b.DB.UserPasswordPairEntry\0327\n\025UserPasswo"
  "rdPairEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:"
  "\0028\001*r\n\tFieldType\022\007\n\003INT\020\000\022\010\n\004LONG\020\001\022\t\n\005F"
  "LOAT\020\002\022\n\n\006DOUBLE\020\003\022\n\n\006STRING\020\004\022\n\n\006VECTOR"
  "\020\005\022\010\n\004BOOL\020\006\022\010\n\004DATE\020\007\022\017\n\013STRINGARRAY\020\010*"
  "\"\n\013FieldOption\022\010\n\004Null\020\000\022\t\n\005Index\020\001B\016H\001Z"
  "\n./vearchpbb\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_data_5fmodel_2eproto_deps[1] = {
  &::descriptor_table_errors_2eproto,
};
static ::_pbi::once_flag descriptor_table_data_5fmodel_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_data_5fmodel_2eproto = {
    false, false, 1299, descriptor_table_protodef_data_5fmodel_2eproto,
    "data_model.proto",
    &descriptor_table_data_5fmodel_2eproto_once, descriptor_table_data_5fmodel_2eproto_deps, 1, 9,
    schemas, file_default_instances, TableStruct_data_5fmodel_2eproto::offsets,
    file_level_metadata_data_5fmodel_2eproto, file_level_enum_descriptors_data_5fmodel_2eproto,
    file_level_service_descriptors_data_5fmodel_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_data_5fmodel_2eproto_getter() {
  return &descriptor_table_data_5fmodel_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_data_5fmodel_2eproto(&descriptor_table_data_5fmodel_2eproto);
namespace vearchpb {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VectorMetaInfo_ValueType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_5fmodel_2eproto);
  return file_level_enum_descriptors_data_5fmodel_2eproto[0];
}
bool VectorMetaInfo_ValueType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr VectorMetaInfo_ValueType VectorMetaInfo::FLOAT;
constexpr VectorMetaInfo_ValueType VectorMetaInfo::UINT8;
constexpr VectorMetaInfo_ValueType VectorMetaInfo::ValueType_MIN;
constexpr VectorMetaInfo_ValueType VectorMetaInfo::ValueType_MAX;
constexpr int VectorMetaInfo::ValueType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VectorMetaInfo_StoreType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_5fmodel_2eproto);
  return file_level_enum_descriptors_data_5fmodel_2eproto[1];
}
bool VectorMetaInfo_StoreType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr VectorMetaInfo_StoreType VectorMetaInfo::MEMORYONLY;
constexpr VectorMetaInfo_StoreType VectorMetaInfo::ROCKSDB;
constexpr VectorMetaInfo_StoreType VectorMetaInfo::StoreType_MIN;
constexpr VectorMetaInfo_StoreType VectorMetaInfo::StoreType_MAX;
constexpr int VectorMetaInfo::StoreType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FieldType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_5fmodel_2eproto);
  return file_level_enum_descriptors_data_5fmodel_2eproto[2];
}
bool FieldType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FieldOption_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_data_5fmodel_2eproto);
  return file_level_enum_descriptors_data_5fmodel_2eproto[3];
}
bool FieldOption_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Field::_Internal {
 public:
};

Field::Field(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vearchpb.Field)
}
Field::Field(const Field& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Field* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.option_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.option_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.option_));
  // @@protoc_insertion_point(copy_constructor:vearchpb.Field)
}

inline void Field::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.option_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Field::~Field() {
  // @@protoc_insertion_point(destructor:vearchpb.Field)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Field::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.value_.Destroy();
}

void Field::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Field::Clear() {
// @@protoc_insertion_point(message_clear_start:vearchpb.Field)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.value_.ClearToEmpty();
  ::memset(&_impl_.type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.option_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.option_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Field::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vearchpb.Field.name"));
        } else
          goto handle_unusual;
        continue;
      // .vearchpb.FieldType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::vearchpb::FieldType>(val));
        } else
          goto handle_unusual;
        continue;
      // bytes value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vearchpb.FieldOption option = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_option(static_cast<::vearchpb::FieldOption>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Field::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vearchpb.Field)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vearchpb.Field.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .vearchpb.FieldType type = 2;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // bytes value = 3;
  if (!this->_internal_value().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_value(), target);
  }

  // .vearchpb.FieldOption option = 4;
  if (this->_internal_option() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_option(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vearchpb.Field)
  return target;
}

size_t Field::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vearchpb.Field)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bytes value = 3;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_value());
  }

  // .vearchpb.FieldType type = 2;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // .vearchpb.FieldOption option = 4;
  if (this->_internal_option() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_option());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Field::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Field::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Field::GetClassData() const { return &_class_data_; }


void Field::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Field*>(&to_msg);
  auto& from = static_cast<const Field&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vearchpb.Field)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_option() != 0) {
    _this->_internal_set_option(from._internal_option());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Field::CopyFrom(const Field& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vearchpb.Field)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Field::IsInitialized() const {
  return true;
}

void Field::InternalSwap(Field* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Field, _impl_.option_)
      + sizeof(Field::_impl_.option_)
      - PROTOBUF_FIELD_OFFSET(Field, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Field::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_5fmodel_2eproto_getter, &descriptor_table_data_5fmodel_2eproto_once,
      file_level_metadata_data_5fmodel_2eproto[0]);
}

// ===================================================================

class Document::_Internal {
 public:
};

Document::Document(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vearchpb.Document)
}
Document::Document(const Document& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Document* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.fields_){from._impl_.fields_}
    , decltype(_impl_.p_key_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.p_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.p_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_p_key().empty()) {
    _this->_impl_.p_key_.Set(from._internal_p_key(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vearchpb.Document)
}

inline void Document::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.fields_){arena}
    , decltype(_impl_.p_key_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.p_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.p_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Document::~Document() {
  // @@protoc_insertion_point(destructor:vearchpb.Document)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Document::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.fields_.~RepeatedPtrField();
  _impl_.p_key_.Destroy();
}

void Document::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Document::Clear() {
// @@protoc_insertion_point(message_clear_start:vearchpb.Document)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.fields_.Clear();
  _impl_.p_key_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Document::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string p_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_p_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vearchpb.Document.p_key"));
        } else
          goto handle_unusual;
        continue;
      // repeated .vearchpb.Field fields = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fields(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Document::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vearchpb.Document)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string p_key = 1;
  if (!this->_internal_p_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_p_key().data(), static_cast<int>(this->_internal_p_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vearchpb.Document.p_key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_p_key(), target);
  }

  // repeated .vearchpb.Field fields = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_fields_size()); i < n; i++) {
    const auto& repfield = this->_internal_fields(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vearchpb.Document)
  return target;
}

size_t Document::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vearchpb.Document)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vearchpb.Field fields = 2;
  total_size += 1UL * this->_internal_fields_size();
  for (const auto& msg : this->_impl_.fields_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string p_key = 1;
  if (!this->_internal_p_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_p_key());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Document::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Document::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Document::GetClassData() const { return &_class_data_; }


void Document::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Document*>(&to_msg);
  auto& from = static_cast<const Document&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vearchpb.Document)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.fields_.MergeFrom(from._impl_.fields_);
  if (!from._internal_p_key().empty()) {
    _this->_internal_set_p_key(from._internal_p_key());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Document::CopyFrom(const Document& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vearchpb.Document)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Document::IsInitialized() const {
  return true;
}

void Document::InternalSwap(Document* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.fields_.InternalSwap(&other->_impl_.fields_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.p_key_, lhs_arena,
      &other->_impl_.p_key_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Document::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_5fmodel_2eproto_getter, &descriptor_table_data_5fmodel_2eproto_once,
      file_level_metadata_data_5fmodel_2eproto[1]);
}

// ===================================================================

class Item::_Internal {
 public:
  static const ::vearchpb::Error& err(const Item* msg);
  static const ::vearchpb::Document& doc(const Item* msg);
};

const ::vearchpb::Error&
Item::_Internal::err(const Item* msg) {
  return *msg->_impl_.err_;
}
const ::vearchpb::Document&
Item::_Internal::doc(const Item* msg) {
  return *msg->_impl_.doc_;
}
void Item::clear_err() {
  if (GetArenaForAllocation() == nullptr && _impl_.err_ != nullptr) {
    delete _impl_.err_;
  }
  _impl_.err_ = nullptr;
}
Item::Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vearchpb.Item)
}
Item::Item(const Item& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Item* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.msg_){}
    , decltype(_impl_.err_){nullptr}
    , decltype(_impl_.doc_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.msg_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_msg().empty()) {
    _this->_impl_.msg_.Set(from._internal_msg(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_err()) {
    _this->_impl_.err_ = new ::vearchpb::Error(*from._impl_.err_);
  }
  if (from._internal_has_doc()) {
    _this->_impl_.doc_ = new ::vearchpb::Document(*from._impl_.doc_);
  }
  // @@protoc_insertion_point(copy_constructor:vearchpb.Item)
}

inline void Item::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.msg_){}
    , decltype(_impl_.err_){nullptr}
    , decltype(_impl_.doc_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.msg_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Item::~Item() {
  // @@protoc_insertion_point(destructor:vearchpb.Item)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Item::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.msg_.Destroy();
  if (this != internal_default_instance()) delete _impl_.err_;
  if (this != internal_default_instance()) delete _impl_.doc_;
}

void Item::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Item::Clear() {
// @@protoc_insertion_point(message_clear_start:vearchpb.Item)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.msg_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.err_ != nullptr) {
    delete _impl_.err_;
  }
  _impl_.err_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.doc_ != nullptr) {
    delete _impl_.doc_;
  }
  _impl_.doc_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Item::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vearchpb.Error err = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_err(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vearchpb.Document doc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_doc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string msg = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_msg();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vearchpb.Item.msg"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Item::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vearchpb.Item)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vearchpb.Error err = 1;
  if (this->_internal_has_err()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::err(this),
        _Internal::err(this).GetCachedSize(), target, stream);
  }

  // .vearchpb.Document doc = 2;
  if (this->_internal_has_doc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::doc(this),
        _Internal::doc(this).GetCachedSize(), target, stream);
  }

  // string msg = 3;
  if (!this->_internal_msg().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_msg().data(), static_cast<int>(this->_internal_msg().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vearchpb.Item.msg");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_msg(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vearchpb.Item)
  return target;
}

size_t Item::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vearchpb.Item)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string msg = 3;
  if (!this->_internal_msg().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_msg());
  }

  // .vearchpb.Error err = 1;
  if (this->_internal_has_err()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.err_);
  }

  // .vearchpb.Document doc = 2;
  if (this->_internal_has_doc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.doc_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Item::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Item::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Item::GetClassData() const { return &_class_data_; }


void Item::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Item*>(&to_msg);
  auto& from = static_cast<const Item&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vearchpb.Item)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_msg().empty()) {
    _this->_internal_set_msg(from._internal_msg());
  }
  if (from._internal_has_err()) {
    _this->_internal_mutable_err()->::vearchpb::Error::MergeFrom(
        from._internal_err());
  }
  if (from._internal_has_doc()) {
    _this->_internal_mutable_doc()->::vearchpb::Document::MergeFrom(
        from._internal_doc());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Item::CopyFrom(const Item& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vearchpb.Item)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Item::IsInitialized() const {
  return true;
}

void Item::InternalSwap(Item* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.msg_, lhs_arena,
      &other->_impl_.msg_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Item, _impl_.doc_)
      + sizeof(Item::_impl_.doc_)
      - PROTOBUF_FIELD_OFFSET(Item, _impl_.err_)>(
          reinterpret_cast<char*>(&_impl_.err_),
          reinterpret_cast<char*>(&other->_impl_.err_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Item::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_5fmodel_2eproto_getter, &descriptor_table_data_5fmodel_2eproto_once,
      file_level_metadata_data_5fmodel_2eproto[2]);
}

// ===================================================================

class VectorMetaInfo::_Internal {
 public:
};

VectorMetaInfo::VectorMetaInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vearchpb.VectorMetaInfo)
}
VectorMetaInfo::VectorMetaInfo(const VectorMetaInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VectorMetaInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.store_param_){}
    , decltype(_impl_.dimension_){}
    , decltype(_impl_.value_type_){}
    , decltype(_impl_.store_type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.store_param_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_param_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_store_param().empty()) {
    _this->_impl_.store_param_.Set(from._internal_store_param(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.dimension_, &from._impl_.dimension_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.store_type_) -
    reinterpret_cast<char*>(&_impl_.dimension_)) + sizeof(_impl_.store_type_));
  // @@protoc_insertion_point(copy_constructor:vearchpb.VectorMetaInfo)
}

inline void VectorMetaInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.store_param_){}
    , decltype(_impl_.dimension_){0}
    , decltype(_impl_.value_type_){0}
    , decltype(_impl_.store_type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.store_param_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_param_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VectorMetaInfo::~VectorMetaInfo() {
  // @@protoc_insertion_point(destructor:vearchpb.VectorMetaInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VectorMetaInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.store_param_.Destroy();
}

void VectorMetaInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VectorMetaInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:vearchpb.VectorMetaInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.store_param_.ClearToEmpty();
  ::memset(&_impl_.dimension_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.store_type_) -
      reinterpret_cast<char*>(&_impl_.dimension_)) + sizeof(_impl_.store_type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VectorMetaInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 dimension = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.dimension_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vearchpb.VectorMetaInfo.ValueType value_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_value_type(static_cast<::vearchpb::VectorMetaInfo_ValueType>(val));
        } else
          goto handle_unusual;
        continue;
      // .vearchpb.VectorMetaInfo.StoreType store_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_store_type(static_cast<::vearchpb::VectorMetaInfo_StoreType>(val));
        } else
          goto handle_unusual;
        continue;
      // string store_param = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_store_param();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vearchpb.VectorMetaInfo.store_param"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VectorMetaInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vearchpb.VectorMetaInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 dimension = 1;
  if (this->_internal_dimension() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_dimension(), target);
  }

  // .vearchpb.VectorMetaInfo.ValueType value_type = 2;
  if (this->_internal_value_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_value_type(), target);
  }

  // .vearchpb.VectorMetaInfo.StoreType store_type = 3;
  if (this->_internal_store_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_store_type(), target);
  }

  // string store_param = 4;
  if (!this->_internal_store_param().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_store_param().data(), static_cast<int>(this->_internal_store_param().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vearchpb.VectorMetaInfo.store_param");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_store_param(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vearchpb.VectorMetaInfo)
  return target;
}

size_t VectorMetaInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vearchpb.VectorMetaInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string store_param = 4;
  if (!this->_internal_store_param().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_store_param());
  }

  // int32 dimension = 1;
  if (this->_internal_dimension() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dimension());
  }

  // .vearchpb.VectorMetaInfo.ValueType value_type = 2;
  if (this->_internal_value_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_value_type());
  }

  // .vearchpb.VectorMetaInfo.StoreType store_type = 3;
  if (this->_internal_store_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_store_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VectorMetaInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VectorMetaInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VectorMetaInfo::GetClassData() const { return &_class_data_; }


void VectorMetaInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VectorMetaInfo*>(&to_msg);
  auto& from = static_cast<const VectorMetaInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vearchpb.VectorMetaInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_store_param().empty()) {
    _this->_internal_set_store_param(from._internal_store_param());
  }
  if (from._internal_dimension() != 0) {
    _this->_internal_set_dimension(from._internal_dimension());
  }
  if (from._internal_value_type() != 0) {
    _this->_internal_set_value_type(from._internal_value_type());
  }
  if (from._internal_store_type() != 0) {
    _this->_internal_set_store_type(from._internal_store_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VectorMetaInfo::CopyFrom(const VectorMetaInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vearchpb.VectorMetaInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VectorMetaInfo::IsInitialized() const {
  return true;
}

void VectorMetaInfo::InternalSwap(VectorMetaInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.store_param_, lhs_arena,
      &other->_impl_.store_param_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VectorMetaInfo, _impl_.store_type_)
      + sizeof(VectorMetaInfo::_impl_.store_type_)
      - PROTOBUF_FIELD_OFFSET(VectorMetaInfo, _impl_.dimension_)>(
          reinterpret_cast<char*>(&_impl_.dimension_),
          reinterpret_cast<char*>(&other->_impl_.dimension_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VectorMetaInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_5fmodel_2eproto_getter, &descriptor_table_data_5fmodel_2eproto_once,
      file_level_metadata_data_5fmodel_2eproto[3]);
}

// ===================================================================

class FieldMetaInfo::_Internal {
 public:
  static const ::vearchpb::VectorMetaInfo& vector_meta_info(const FieldMetaInfo* msg);
};

const ::vearchpb::VectorMetaInfo&
FieldMetaInfo::_Internal::vector_meta_info(const FieldMetaInfo* msg) {
  return *msg->_impl_.vector_meta_info_;
}
FieldMetaInfo::FieldMetaInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vearchpb.FieldMetaInfo)
}
FieldMetaInfo::FieldMetaInfo(const FieldMetaInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FieldMetaInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.vector_meta_info_){nullptr}
    , decltype(_impl_.data_type_){}
    , decltype(_impl_.is_index_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_vector_meta_info()) {
    _this->_impl_.vector_meta_info_ = new ::vearchpb::VectorMetaInfo(*from._impl_.vector_meta_info_);
  }
  ::memcpy(&_impl_.data_type_, &from._impl_.data_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_index_) -
    reinterpret_cast<char*>(&_impl_.data_type_)) + sizeof(_impl_.is_index_));
  // @@protoc_insertion_point(copy_constructor:vearchpb.FieldMetaInfo)
}

inline void FieldMetaInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.vector_meta_info_){nullptr}
    , decltype(_impl_.data_type_){0}
    , decltype(_impl_.is_index_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FieldMetaInfo::~FieldMetaInfo() {
  // @@protoc_insertion_point(destructor:vearchpb.FieldMetaInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FieldMetaInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.vector_meta_info_;
}

void FieldMetaInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FieldMetaInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:vearchpb.FieldMetaInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.vector_meta_info_ != nullptr) {
    delete _impl_.vector_meta_info_;
  }
  _impl_.vector_meta_info_ = nullptr;
  ::memset(&_impl_.data_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.is_index_) -
      reinterpret_cast<char*>(&_impl_.data_type_)) + sizeof(_impl_.is_index_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FieldMetaInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vearchpb.FieldMetaInfo.name"));
        } else
          goto handle_unusual;
        continue;
      // .vearchpb.FieldType data_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_data_type(static_cast<::vearchpb::FieldType>(val));
        } else
          goto handle_unusual;
        continue;
      // bool is_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.is_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vearchpb.VectorMetaInfo vector_meta_info = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_vector_meta_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FieldMetaInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vearchpb.FieldMetaInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vearchpb.FieldMetaInfo.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .vearchpb.FieldType data_type = 2;
  if (this->_internal_data_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_data_type(), target);
  }

  // bool is_index = 3;
  if (this->_internal_is_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_index(), target);
  }

  // .vearchpb.VectorMetaInfo vector_meta_info = 4;
  if (this->_internal_has_vector_meta_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::vector_meta_info(this),
        _Internal::vector_meta_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vearchpb.FieldMetaInfo)
  return target;
}

size_t FieldMetaInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vearchpb.FieldMetaInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vearchpb.VectorMetaInfo vector_meta_info = 4;
  if (this->_internal_has_vector_meta_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.vector_meta_info_);
  }

  // .vearchpb.FieldType data_type = 2;
  if (this->_internal_data_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_data_type());
  }

  // bool is_index = 3;
  if (this->_internal_is_index() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FieldMetaInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FieldMetaInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FieldMetaInfo::GetClassData() const { return &_class_data_; }


void FieldMetaInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FieldMetaInfo*>(&to_msg);
  auto& from = static_cast<const FieldMetaInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vearchpb.FieldMetaInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_vector_meta_info()) {
    _this->_internal_mutable_vector_meta_info()->::vearchpb::VectorMetaInfo::MergeFrom(
        from._internal_vector_meta_info());
  }
  if (from._internal_data_type() != 0) {
    _this->_internal_set_data_type(from._internal_data_type());
  }
  if (from._internal_is_index() != 0) {
    _this->_internal_set_is_index(from._internal_is_index());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FieldMetaInfo::CopyFrom(const FieldMetaInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vearchpb.FieldMetaInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FieldMetaInfo::IsInitialized() const {
  return true;
}

void FieldMetaInfo::InternalSwap(FieldMetaInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FieldMetaInfo, _impl_.is_index_)
      + sizeof(FieldMetaInfo::_impl_.is_index_)
      - PROTOBUF_FIELD_OFFSET(FieldMetaInfo, _impl_.vector_meta_info_)>(
          reinterpret_cast<char*>(&_impl_.vector_meta_info_),
          reinterpret_cast<char*>(&other->_impl_.vector_meta_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FieldMetaInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_5fmodel_2eproto_getter, &descriptor_table_data_5fmodel_2eproto_once,
      file_level_metadata_data_5fmodel_2eproto[4]);
}

// ===================================================================

class TableMetaInfo::_Internal {
 public:
};

TableMetaInfo::TableMetaInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vearchpb.TableMetaInfo)
}
TableMetaInfo::TableMetaInfo(const TableMetaInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TableMetaInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.field_meta_info_){from._impl_.field_meta_info_}
    , decltype(_impl_.primary_key_name_){}
    , decltype(_impl_.primary_key_type_){}
    , decltype(_impl_.partitions_num_){}
    , decltype(_impl_.replicas_num_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.primary_key_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.primary_key_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_primary_key_name().empty()) {
    _this->_impl_.primary_key_name_.Set(from._internal_primary_key_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.primary_key_type_, &from._impl_.primary_key_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.replicas_num_) -
    reinterpret_cast<char*>(&_impl_.primary_key_type_)) + sizeof(_impl_.replicas_num_));
  // @@protoc_insertion_point(copy_constructor:vearchpb.TableMetaInfo)
}

inline void TableMetaInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.field_meta_info_){arena}
    , decltype(_impl_.primary_key_name_){}
    , decltype(_impl_.primary_key_type_){0}
    , decltype(_impl_.partitions_num_){0}
    , decltype(_impl_.replicas_num_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.primary_key_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.primary_key_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TableMetaInfo::~TableMetaInfo() {
  // @@protoc_insertion_point(destructor:vearchpb.TableMetaInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TableMetaInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.field_meta_info_.~RepeatedPtrField();
  _impl_.primary_key_name_.Destroy();
}

void TableMetaInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TableMetaInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:vearchpb.TableMetaInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.field_meta_info_.Clear();
  _impl_.primary_key_name_.ClearToEmpty();
  ::memset(&_impl_.primary_key_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.replicas_num_) -
      reinterpret_cast<char*>(&_impl_.primary_key_type_)) + sizeof(_impl_.replicas_num_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TableMetaInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string primary_key_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_primary_key_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vearchpb.TableMetaInfo.primary_key_name"));
        } else
          goto handle_unusual;
        continue;
      // .vearchpb.FieldType primary_key_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_primary_key_type(static_cast<::vearchpb::FieldType>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 partitions_num = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.partitions_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 replicas_num = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.replicas_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vearchpb.FieldMetaInfo field_meta_info = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_field_meta_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TableMetaInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vearchpb.TableMetaInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string primary_key_name = 1;
  if (!this->_internal_primary_key_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_primary_key_name().data(), static_cast<int>(this->_internal_primary_key_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vearchpb.TableMetaInfo.primary_key_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_primary_key_name(), target);
  }

  // .vearchpb.FieldType primary_key_type = 2;
  if (this->_internal_primary_key_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_primary_key_type(), target);
  }

  // int32 partitions_num = 3;
  if (this->_internal_partitions_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_partitions_num(), target);
  }

  // int32 replicas_num = 4;
  if (this->_internal_replicas_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_replicas_num(), target);
  }

  // repeated .vearchpb.FieldMetaInfo field_meta_info = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_field_meta_info_size()); i < n; i++) {
    const auto& repfield = this->_internal_field_meta_info(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vearchpb.TableMetaInfo)
  return target;
}

size_t TableMetaInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vearchpb.TableMetaInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vearchpb.FieldMetaInfo field_meta_info = 5;
  total_size += 1UL * this->_internal_field_meta_info_size();
  for (const auto& msg : this->_impl_.field_meta_info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string primary_key_name = 1;
  if (!this->_internal_primary_key_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_primary_key_name());
  }

  // .vearchpb.FieldType primary_key_type = 2;
  if (this->_internal_primary_key_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_primary_key_type());
  }

  // int32 partitions_num = 3;
  if (this->_internal_partitions_num() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_partitions_num());
  }

  // int32 replicas_num = 4;
  if (this->_internal_replicas_num() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_replicas_num());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TableMetaInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TableMetaInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TableMetaInfo::GetClassData() const { return &_class_data_; }


void TableMetaInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TableMetaInfo*>(&to_msg);
  auto& from = static_cast<const TableMetaInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vearchpb.TableMetaInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.field_meta_info_.MergeFrom(from._impl_.field_meta_info_);
  if (!from._internal_primary_key_name().empty()) {
    _this->_internal_set_primary_key_name(from._internal_primary_key_name());
  }
  if (from._internal_primary_key_type() != 0) {
    _this->_internal_set_primary_key_type(from._internal_primary_key_type());
  }
  if (from._internal_partitions_num() != 0) {
    _this->_internal_set_partitions_num(from._internal_partitions_num());
  }
  if (from._internal_replicas_num() != 0) {
    _this->_internal_set_replicas_num(from._internal_replicas_num());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TableMetaInfo::CopyFrom(const TableMetaInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vearchpb.TableMetaInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableMetaInfo::IsInitialized() const {
  return true;
}

void TableMetaInfo::InternalSwap(TableMetaInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.field_meta_info_.InternalSwap(&other->_impl_.field_meta_info_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.primary_key_name_, lhs_arena,
      &other->_impl_.primary_key_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TableMetaInfo, _impl_.replicas_num_)
      + sizeof(TableMetaInfo::_impl_.replicas_num_)
      - PROTOBUF_FIELD_OFFSET(TableMetaInfo, _impl_.primary_key_type_)>(
          reinterpret_cast<char*>(&_impl_.primary_key_type_),
          reinterpret_cast<char*>(&other->_impl_.primary_key_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TableMetaInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_5fmodel_2eproto_getter, &descriptor_table_data_5fmodel_2eproto_once,
      file_level_metadata_data_5fmodel_2eproto[5]);
}

// ===================================================================

class Table::_Internal {
 public:
  static const ::vearchpb::TableMetaInfo& table_meta_info(const Table* msg);
};

const ::vearchpb::TableMetaInfo&
Table::_Internal::table_meta_info(const Table* msg) {
  return *msg->_impl_.table_meta_info_;
}
Table::Table(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vearchpb.Table)
}
Table::Table(const Table& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Table* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.table_meta_info_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_table_meta_info()) {
    _this->_impl_.table_meta_info_ = new ::vearchpb::TableMetaInfo(*from._impl_.table_meta_info_);
  }
  // @@protoc_insertion_point(copy_constructor:vearchpb.Table)
}

inline void Table::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.table_meta_info_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Table::~Table() {
  // @@protoc_insertion_point(destructor:vearchpb.Table)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Table::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.table_meta_info_;
}

void Table::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Table::Clear() {
// @@protoc_insertion_point(message_clear_start:vearchpb.Table)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.table_meta_info_ != nullptr) {
    delete _impl_.table_meta_info_;
  }
  _impl_.table_meta_info_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Table::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vearchpb.Table.name"));
        } else
          goto handle_unusual;
        continue;
      // .vearchpb.TableMetaInfo table_meta_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_table_meta_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Table::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vearchpb.Table)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vearchpb.Table.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .vearchpb.TableMetaInfo table_meta_info = 2;
  if (this->_internal_has_table_meta_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::table_meta_info(this),
        _Internal::table_meta_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vearchpb.Table)
  return target;
}

size_t Table::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vearchpb.Table)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vearchpb.TableMetaInfo table_meta_info = 2;
  if (this->_internal_has_table_meta_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.table_meta_info_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Table::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Table::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Table::GetClassData() const { return &_class_data_; }


void Table::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Table*>(&to_msg);
  auto& from = static_cast<const Table&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vearchpb.Table)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_table_meta_info()) {
    _this->_internal_mutable_table_meta_info()->::vearchpb::TableMetaInfo::MergeFrom(
        from._internal_table_meta_info());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Table::CopyFrom(const Table& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vearchpb.Table)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Table::IsInitialized() const {
  return true;
}

void Table::InternalSwap(Table* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.table_meta_info_, other->_impl_.table_meta_info_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Table::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_5fmodel_2eproto_getter, &descriptor_table_data_5fmodel_2eproto_once,
      file_level_metadata_data_5fmodel_2eproto[6]);
}

// ===================================================================

DB_UserPasswordPairEntry_DoNotUse::DB_UserPasswordPairEntry_DoNotUse() {}
DB_UserPasswordPairEntry_DoNotUse::DB_UserPasswordPairEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void DB_UserPasswordPairEntry_DoNotUse::MergeFrom(const DB_UserPasswordPairEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata DB_UserPasswordPairEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_5fmodel_2eproto_getter, &descriptor_table_data_5fmodel_2eproto_once,
      file_level_metadata_data_5fmodel_2eproto[7]);
}

// ===================================================================

class DB::_Internal {
 public:
};

DB::DB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &DB::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:vearchpb.DB)
}
DB::DB(const DB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tables_){from._impl_.tables_}
    , /*decltype(_impl_.user_password_pair_)*/{}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.user_password_pair_.MergeFrom(from._impl_.user_password_pair_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vearchpb.DB)
}

inline void DB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tables_){arena}
    , /*decltype(_impl_.user_password_pair_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DB::~DB() {
  // @@protoc_insertion_point(destructor:vearchpb.DB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void DB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tables_.~RepeatedPtrField();
  _impl_.user_password_pair_.Destruct();
  _impl_.user_password_pair_.~MapField();
  _impl_.name_.Destroy();
}

void DB::ArenaDtor(void* object) {
  DB* _this = reinterpret_cast< DB* >(object);
  _this->_impl_.user_password_pair_.Destruct();
}
void DB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DB::Clear() {
// @@protoc_insertion_point(message_clear_start:vearchpb.DB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tables_.Clear();
  _impl_.user_password_pair_.Clear();
  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vearchpb.DB.name"));
        } else
          goto handle_unusual;
        continue;
      // repeated .vearchpb.Table tables = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tables(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, string> user_password_pair = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.user_password_pair_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vearchpb.DB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vearchpb.DB.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated .vearchpb.Table tables = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tables_size()); i < n; i++) {
    const auto& repfield = this->_internal_tables(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // map<string, string> user_password_pair = 3;
  if (!this->_internal_user_password_pair().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = DB_UserPasswordPairEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_user_password_pair();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "vearchpb.DB.UserPasswordPairEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "vearchpb.DB.UserPasswordPairEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vearchpb.DB)
  return target;
}

size_t DB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vearchpb.DB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vearchpb.Table tables = 2;
  total_size += 1UL * this->_internal_tables_size();
  for (const auto& msg : this->_impl_.tables_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, string> user_password_pair = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_user_password_pair_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_user_password_pair().begin();
      it != this->_internal_user_password_pair().end(); ++it) {
    total_size += DB_UserPasswordPairEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DB::GetClassData() const { return &_class_data_; }


void DB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DB*>(&to_msg);
  auto& from = static_cast<const DB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vearchpb.DB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tables_.MergeFrom(from._impl_.tables_);
  _this->_impl_.user_password_pair_.MergeFrom(from._impl_.user_password_pair_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DB::CopyFrom(const DB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vearchpb.DB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DB::IsInitialized() const {
  return true;
}

void DB::InternalSwap(DB* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tables_.InternalSwap(&other->_impl_.tables_);
  _impl_.user_password_pair_.InternalSwap(&other->_impl_.user_password_pair_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata DB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_5fmodel_2eproto_getter, &descriptor_table_data_5fmodel_2eproto_once,
      file_level_metadata_data_5fmodel_2eproto[8]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace vearchpb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::vearchpb::Field*
Arena::CreateMaybeMessage< ::vearchpb::Field >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vearchpb::Field >(arena);
}
template<> PROTOBUF_NOINLINE ::vearchpb::Document*
Arena::CreateMaybeMessage< ::vearchpb::Document >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vearchpb::Document >(arena);
}
template<> PROTOBUF_NOINLINE ::vearchpb::Item*
Arena::CreateMaybeMessage< ::vearchpb::Item >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vearchpb::Item >(arena);
}
template<> PROTOBUF_NOINLINE ::vearchpb::VectorMetaInfo*
Arena::CreateMaybeMessage< ::vearchpb::VectorMetaInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vearchpb::VectorMetaInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::vearchpb::FieldMetaInfo*
Arena::CreateMaybeMessage< ::vearchpb::FieldMetaInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vearchpb::FieldMetaInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::vearchpb::TableMetaInfo*
Arena::CreateMaybeMessage< ::vearchpb::TableMetaInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vearchpb::TableMetaInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::vearchpb::Table*
Arena::CreateMaybeMessage< ::vearchpb::Table >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vearchpb::Table >(arena);
}
template<> PROTOBUF_NOINLINE ::vearchpb::DB_UserPasswordPairEntry_DoNotUse*
Arena::CreateMaybeMessage< ::vearchpb::DB_UserPasswordPairEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vearchpb::DB_UserPasswordPairEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::vearchpb::DB*
Arena::CreateMaybeMessage< ::vearchpb::DB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vearchpb::DB >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
